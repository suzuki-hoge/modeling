### モデリングのポイント
+ タクシーは状態毎にクラスを分け、実行例外を無くす
  + リポジトリはエンティティ毎に存在する
+ タクシーで共通のInterfaceは設けない
+ repositoryを除く、domain層での副作用を禁じる
  + それらはモックなしでテスト出来る事
+ ロジックはDomainServiceか、ValueObjectに書く
  + 必要であればdomain層の関数のテストを書く
+ この規模だと無かったけど、個人的にはサービス層にprivateメソッドを切るのを禁じてみたい
  + 大抵はDomainServiceかValueObjectに持って行けるはずだから
  + というか、関数は全てドメイン層に入るはず
+ domain層は参照透過性があるメソッドだけ、それ以外の層は副作用があるメソッドだけ縛りをしたい
+ DomainServiceは状態に依存せず、必ず参照透過性を保つたせるために、static(scalaだとobject)に限る
  + それだとリポジトリのDIも出来ないし
+ 業務上発生する異常はEitherで、システム上発生する異常は例外で表現する
  + Eitherはドメインモデルに現れ、例外は現れない
+ DomainServiceを切ったけど、EmptyTaxiしか受けないのであればEmptyTaxisを作ってそっちに移譲しても良かった
  + そうするとPickUpServiceの中が引数渡しからチェインに出来るので、前から後ろに素直に読める
  + ただ時間の計算とか到着予定とか出てくると、DomainServiceの方が適しだす気がする
  + now()は冪等性がないので、リストクラスの中で取得する様な作りは断固したくない　テスト辛いし
+ 仕様上、時間の概念は出していないので、直線距離で計算して向かわせるまで
  + 〜分後に到着予定ですとか言って電話を切りたいなら、Distanseあたりを使って計算して、Rightで返せば良いのですぐ対応出来る想定
+ リポジトリはリポジトリのInterface名と引数/戻り値の型がしっかりしているので、メソッド名は短くて良いと思っている

### 感想・補足
+ パッケージも考えるとなお良い訓練になる気がした
+ 時間は直接お題に必要では無かったので省略した
  + 必要なら、要請受領時、乗車時、等クラスを分け、タクシーと同じように次を吐く様な作りにする
+ 待たせているユーザは管理しない
+ コーディングはメソッド名と引数と戻りを見て図通りに関数定義して、適当に型が合う様に書けば良かった
+ DIは適当
+ モデルと実装の乖離は1つ2つ引数が欠けているくらいだった
+ コーディングは答え合わせって誰かが言ってたけど、そんな感じだった
+ 集約を書きたかった
  + 運転手でも出したら集約出てくるかな？

### 他
+ モデリングおよび実装の段階で、一番近くのタクシーに向かう様に連絡する処理がまるっと抜けていたので追記した
  + これはシーケンス図で抜ける？
  + どちらかと言うと発想から抜けていたので、何を書いても抜けた説
  + 急に思いついて直した
  + エンティティを1つリポジトリに渡すだけなので、ドメイン不整合は起きなかったはず...
+ 全ての参照を正しく書くとPlantUMLが破綻するので、かいつまんで
+ フィールドと参照どっちで書くか迷うことが結構ある
  + TaxiIdやPointは複数箇所が用いるのを明示したかったので参照で書いた
  + CurrentPoint等もPointへの線を明示したかったので参照で書いた
